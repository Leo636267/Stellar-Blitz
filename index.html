<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>STELLAR BLITZ</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap');
  * { margin:0; padding:0; box-sizing:border-box; }
  :root {
    --neon-cyan:#00f0ff; --neon-pink:#ff2d7b;
    --neon-yellow:#ffe600; --neon-green:#39ff14;
    --dark-bg:#0a0a1a; --panel-bg:rgba(10,10,30,0.85);
  }
  html, body { height:100%; }
  body {
    background:var(--dark-bg); font-family:'Orbitron',sans-serif;
    color:#fff; overflow:hidden; height:100%;
    display:flex; flex-direction:column; align-items:center; justify-content:center;
    user-select:none; -webkit-user-select:none;
  }

  /* â”€â”€ Canvas responsive + landscape support â”€â”€ */
  #game-wrap {
    position:relative;
    width:680px; max-width:100vw; max-height:calc(100vh - 0px);
    aspect-ratio:680/720;
  }
  
  /* Force landscape on mobile â€” shrunk to clear browser chrome */
  @media (max-width: 768px) and (orientation: portrait) {
    #game-wrap {
      transform: rotate(90deg);
      transform-origin: center center;
      width: calc(100vh - 50px);
      height: 100vw;
      max-width: calc(100vh - 50px);
      max-height: 100vw;
      position: fixed;
      top: 50%;
      left: 50%;
      margin-left: calc(-50vh + 25px);
      margin-top: -50vw;
    }
  }
  /* Landscape orientation on mobile â€” also constrain */
  @media (max-width: 768px) and (orientation: landscape) {
    #game-wrap {
      max-height: calc(100vh - 30px);
      max-width: calc(100vw - 20px);
    }
  }
  
  canvas {
    display:block; width:100%; height:100%;
    border:1px solid rgba(0,240,255,0.15);
    box-shadow:0 0 40px rgba(0,240,255,0.08),inset 0 0 80px rgba(0,0,0,0.6);
    border-radius:4px;
    touch-action:none; /* prevent scroll/zoom on canvas */
  }

  /* â”€â”€ HUD â”€â”€ */
  #hud {
    position:absolute; top:0; left:0; right:0;
    display:flex; justify-content:space-between; align-items:center;
    padding:8px 16px; background:var(--panel-bg);
    border-bottom:1px solid rgba(0,240,255,0.15);
    border-radius:4px 4px 0 0;
    z-index:10; pointer-events:none;
  }
  .hud-item { display:flex; flex-direction:column; gap:1px; }
  .hud-label { font-size:8px; text-transform:uppercase; letter-spacing:2px;
    color:rgba(0,240,255,0.5); font-family:'Share Tech Mono',monospace; }
  .hud-value { font-size:15px; font-weight:700; color:var(--neon-cyan);
    text-shadow:0 0 8px rgba(0,240,255,0.5); font-family:'Share Tech Mono',monospace; }
  #lives-display { display:flex; gap:5px; align-items:center; }
  .life-icon { width:11px; height:14px; background:var(--neon-cyan);
    clip-path:polygon(50% 0%,100% 100%,0% 100%); box-shadow:0 0 5px var(--neon-cyan); }
  
  /* Mobile: move lives to left side to avoid button overlap */
  @media (hover:none) and (pointer:coarse) {
    #hud { padding:6px 10px; }
    .hud-item:last-child { order: -1; } /* Move lives to start */
  }

  /* â”€â”€ ON-SCREEN CONTROLS (mobile only) â”€â”€ */
  #mobile-controls {
    position:absolute; bottom:0; left:0; right:0; height:140px;
    display:none; z-index:12; pointer-events:none;
  }
  /* Show on touch devices only */
  @media (hover:none) and (pointer:coarse) {
    #mobile-controls { display:block; }
  }
  /* Fallback for Samsung devices where hover:none fails â€” still check pointer:coarse */
  @media (max-width: 768px) and (pointer:coarse) {
    #mobile-controls { display:block !important; }
  }
  
  /* Joystick (left) */
  #joystick-area {
    position:absolute; bottom:20px; left:20px;
    width:100px; height:100px; pointer-events:all;
  }
  #joystick-base {
    width:100%; height:100%; border-radius:50%;
    background:rgba(0,240,255,0.15); border:2px solid rgba(0,240,255,0.3);
    position:relative;
  }
  #joystick-stick {
    position:absolute; top:50%; left:50%;
    width:45px; height:45px; margin:-22.5px 0 0 -22.5px;
    border-radius:50%; background:rgba(0,240,255,0.4);
    border:2px solid var(--neon-cyan); box-shadow:0 0 12px rgba(0,240,255,0.5);
  }
  
  /* Shoot button (right) */
  #shoot-btn {
    position:absolute; bottom:20px; right:20px;
    width:90px; height:90px; border-radius:50%;
    background:rgba(255,45,123,0.2); border:3px solid rgba(255,45,123,0.5);
    display:flex; align-items:center; justify-content:center;
    font-size:14px; font-weight:700; color:var(--neon-pink);
    text-shadow:0 0 8px rgba(255,45,123,0.6);
    pointer-events:all; user-select:none;
  }
  #shoot-btn:active {
    background:rgba(255,45,123,0.4);
    box-shadow:0 0 20px rgba(255,45,123,0.8);
  }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     MENU OVERLAY â€” pale frosted design
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  #overlay {
    position:absolute; inset:0; z-index:20; transition:opacity 0.35s;
    pointer-events:all; overflow:hidden;
  }
  #overlay.hidden { opacity:0; pointer-events:none; }

  /* Pale frosted background panel */
  #overlay-panel {
    position:absolute; inset:0;
    background: linear-gradient(160deg,
      rgba(200,215,235,0.92) 0%,
      rgba(185,200,225,0.88) 40%,
      rgba(175,190,220,0.90) 100%);
    backdrop-filter: blur(12px) saturate(1.4);
  }

  /* Geometric accent grid â€” subtle lines */
  #overlay-grid {
    position:absolute; inset:0; pointer-events:none; opacity:0.18;
    background-image:
      linear-gradient(rgba(0,100,160,0.4) 1px, transparent 1px),
      linear-gradient(90deg, rgba(0,100,160,0.4) 1px, transparent 1px);
    background-size:40px 40px;
  }
  /* Diagonal accent stripe */
  #overlay-stripe {
    position:absolute; top:-20%; right:-10%; width:55%; height:140%;
    background:linear-gradient(135deg, transparent 45%, rgba(0,180,220,0.07) 45%, rgba(0,180,220,0.07) 55%, transparent 55%);
    pointer-events:none;
  }
  /* Corner accent dots */
  #overlay-dots {
    position:absolute; inset:0; pointer-events:none;
  }
  #overlay-dots::before, #overlay-dots::after {
    content:''; position:absolute;
    width:180px; height:180px; border-radius:50%;
    border:1px solid rgba(0,140,180,0.25);
  }
  #overlay-dots::before { top:-60px; left:-60px; }
  #overlay-dots::after  { bottom:-80px; right:-80px; width:220px; height:220px; border-color:rgba(0,140,180,0.15); }

  /* Title block â€” top center */
  #overlay-top {
    position:absolute; top:28px; left:0; right:0;
    display:flex; flex-direction:column; align-items:center; z-index:2;
  }
  #overlay h1 {
    font-size:clamp(32px,7vw,62px); font-weight:900; letter-spacing:6px; text-transform:uppercase;
    background:linear-gradient(135deg, #0a3d5c, #1a6fa0, #0a3d5c);
    -webkit-background-clip:text; -webkit-text-fill-color:transparent;
    filter:drop-shadow(0 2px 8px rgba(0,100,160,0.25)); margin-bottom:6px;
  }
  .subtitle { font-family:'Share Tech Mono',monospace; font-size:clamp(9px,2vw,13px);
    color:rgba(40,70,100,0.55); letter-spacing:4px; text-transform:uppercase; }

  /* Bottom-right block â€” scores + buttons */
  #overlay-bottom {
    position:absolute; bottom:40px; right:40px;
    display:flex; flex-direction:column; align-items:flex-end; gap:18px; z-index:2;
  }

  .score-row { display:flex; gap:36px; }
  .score-col { text-align:right; }
  .score-col .s-label { font-family:'Share Tech Mono',monospace; font-size:9px;
    color:rgba(40,70,100,0.5); letter-spacing:3px; text-transform:uppercase; margin-bottom:2px; }
  .score-col .s-value { font-family:'Share Tech Mono',monospace; font-size:30px; font-weight:700; }
  #overlay-score { color:#c45a00; text-shadow:0 1px 4px rgba(180,80,0,0.3); }
  #overlay-best  { color:#1a7a3a; text-shadow:0 1px 4px rgba(20,120,50,0.3); }
  .score-row.hidden { display:none; }

  .btn-row { display:flex; flex-direction:column; gap:12px; align-items:flex-end; }
  .btn-row .btn-actions { display:flex; gap:12px; }
  .btn {
    font-family:'Orbitron',sans-serif; font-size:12px; font-weight:700;
    letter-spacing:2px; text-transform:uppercase; color:#fff;
    background:linear-gradient(135deg, #0a5a8a, #0d7ab5);
    border:none; padding:13px 34px; border-radius:5px; cursor:pointer;
    pointer-events:all; transition:all 0.2s;
    box-shadow:0 3px 12px rgba(0,100,160,0.35);
  }
  .btn:hover { background:linear-gradient(135deg, #0d6d9f, #1088c8);
    box-shadow:0 4px 18px rgba(0,100,160,0.5); transform:translateY(-1px); }
  .btn:active { transform:translateY(0); }
  .btn.secondary {
    background:rgba(255,255,255,0.55); color:#2a5a7a;
    box-shadow:0 2px 8px rgba(0,80,120,0.15); font-size:11px; padding:10px 24px;
    border:1px solid rgba(0,100,160,0.2);
  }
  .btn.secondary:hover { background:rgba(255,255,255,0.75);
    box-shadow:0 3px 12px rgba(0,80,120,0.25); }

  /* â”€â”€ Death log card (game over screen) â”€â”€ */
  .death-log {
    background:rgba(255,255,255,0.12);
    border:1px solid rgba(0,100,160,0.18);
    border-radius:8px; padding:12px 18px;
    display:flex; flex-direction:column; gap:6px;
    backdrop-filter:blur(3px);
    margin-bottom:4px;
  }
  .death-log-title {
    font-family:'Share Tech Mono',monospace;
    font-size:8px; letter-spacing:3px; text-transform:uppercase;
    color:rgba(40,70,100,0.45); margin-bottom:2px;
    padding-bottom:6px;
    border-bottom:1px solid rgba(0,100,160,0.15);
  }
  .death-log-entry {
    font-family:'Share Tech Mono',monospace;
    font-size:10px; color:rgba(30,55,85,0.75);
    letter-spacing:0.5px; display:flex; align-items:center; gap:8px;
  }
  .death-log-entry .log-num {
    font-size:9px; font-weight:700; color:rgba(180,60,60,0.7);
    min-width:18px; text-align:right; flex-shrink:0;
  }
  .death-log-entry .log-icon { flex-shrink:0; font-size:11px; }
  .death-log-entry .log-text { flex:1; }

  /* Menu highscore â€” bottom left */
  #menu-hs {
    position:absolute; bottom:40px; left:40px;
    display:none; flex-direction:column; align-items:flex-start; gap:3px; z-index:2;
  }
  #menu-hs.visible { display:flex; }
  #menu-hs .hs-label {
    font-family:'Share Tech Mono',monospace; font-size:8px;
    color:rgba(40,70,100,0.45); letter-spacing:3px; text-transform:uppercase;
  }
  #menu-hs .hs-value {
    font-family:'Share Tech Mono',monospace; font-size:26px; font-weight:700;
    color:#1a7a3a; text-shadow:0 1px 4px rgba(20,120,50,0.3);
  }

  /* Audio slider panel â€” top-left */
  #audio-controls {
    position:absolute; top:36px; left:24px; z-index:3;
    display:flex; flex-direction:column; gap:6px;
  }
  @media (min-width: 600px) {
    /* Desktop / landscape â€” move down to avoid title overlap */
    #audio-controls { top:98px; }
  }
  .audio-row {
    display:flex; align-items:center; gap:6px;
    background:rgba(255,255,255,0.18); border-radius:6px;
    padding:5px 8px; backdrop-filter:blur(4px);
  }
  .audio-icon { font-size:14px; width:18px; text-align:center; flex-shrink:0; }
  .audio-slider-wrap {
    width:80px; height:20px;
    display:flex; align-items:center;
    cursor:pointer;
    -webkit-tap-highlight-color:transparent;
  }
  .audio-slider-track {
    position:relative; width:100%; height:5px;
    background:rgba(0,100,160,0.25); border-radius:3px;
  }
  .audio-slider-fill {
    position:absolute; top:0; left:0; height:100%;
    background:linear-gradient(90deg, rgba(0,180,220,0.7), var(--neon-cyan));
    border-radius:3px; width:50%; /* JS driven */
  }
  .audio-slider-thumb {
    position:absolute; top:50%;
    width:16px; height:16px; border-radius:50%;
    background:var(--neon-cyan);
    box-shadow:0 0 5px rgba(0,240,255,0.55);
    transform:translate(-50%, -50%);
    left:50%; /* JS driven */
  }

  /* â”€â”€ Controls hint â”€â”€ */
  #controls-hint {
    position:absolute; bottom:8px; left:0; right:0; text-align:center;
    font-family:'Share Tech Mono',monospace; font-size:9px;
    color:rgba(40,70,100,0.4); letter-spacing:2px;
    pointer-events:none; z-index:5;
  }
  #controls-hint span { color:rgba(0,100,160,0.6); font-weight:700; }
  .hint-desktop { display:inline; }
  .hint-mobile  { display:none; }
  @media (hover:none) and (pointer:coarse) {
    .hint-desktop { display:none; }
    .hint-mobile  { display:inline; }
  }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     PAUSE OVERLAY
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  #pause-overlay {
    position:absolute; inset:0; z-index:30;
    background:rgba(5,5,18,0.7); backdrop-filter:blur(3px);
    display:none; flex-direction:column; align-items:center; justify-content:center; gap:28px;
    pointer-events:all;
  }
  #pause-overlay.visible { display:flex; }
  #pause-overlay h2 {
    font-size:clamp(28px,6vw,44px); font-weight:900; letter-spacing:6px;
    text-transform:uppercase; color:var(--neon-cyan);
    text-shadow:0 0 18px rgba(0,240,255,0.45);
  }
  #pause-overlay .pause-btn-row { display:flex; gap:12px; }
  .pause-btn {
    font-family:'Orbitron',sans-serif; font-size:11px; font-weight:700;
    letter-spacing:2px; text-transform:uppercase; color:#fff;
    background:transparent; border:1px solid var(--neon-cyan);
    padding:11px 30px; border-radius:4px; cursor:pointer;
    transition:all 0.2s;
    box-shadow:0 0 10px rgba(0,240,255,0.15);
  }
  .pause-btn:hover { background:rgba(0,240,255,0.12);
    box-shadow:0 0 20px rgba(0,240,255,0.3); }
  .pause-btn.sec { border-color:rgba(255,255,255,0.2); color:rgba(255,255,255,0.5);
    box-shadow:none; font-size:10px; padding:9px 22px; }
  .pause-btn.sec:hover { border-color:rgba(255,255,255,0.45); color:#fff;
    background:rgba(255,255,255,0.05); }

  /* â”€â”€ In-game pause button (top-right, mobile only) â”€â”€ */
  #pause-btn {
    position:absolute; top:6px; right:6px; z-index:11;
    width:34px; height:34px; border-radius:6px;
    background:rgba(10,10,30,0.75); border:1px solid rgba(0,240,255,0.35);
    display:none; align-items:center; justify-content:center;
    cursor:pointer; pointer-events:all; backdrop-filter:blur(4px);
  }
  #pause-btn.visible { display:flex; }
  #pause-btn svg { width:16px; height:16px; }

  /* â”€â”€ NEW HIGHSCORE celebration â”€â”€ */
  #new-hs-banner {
    position:absolute; inset:0; z-index:25;
    display:none; flex-direction:column; align-items:center; justify-content:center;
    pointer-events:none;
  }
  #new-hs-banner.visible { display:flex; }
  #new-hs-banner .banner-text {
    font-family:'Orbitron',sans-serif; font-size:clamp(28px,6vw,48px);
    font-weight:900; letter-spacing:4px; text-transform:uppercase;
    color:var(--neon-yellow);
    text-shadow: 0 0 12px rgba(255,230,0,0.7), 0 0 40px rgba(255,200,0,0.4);
    animation: bannerPulse 0.6s ease-in-out infinite alternate;
  }
  #new-hs-banner .banner-sub {
    font-family:'Share Tech Mono',monospace; font-size:clamp(11px,2.5vw,16px);
    color:rgba(255,230,0,0.7); letter-spacing:6px; margin-top:8px;
    text-shadow: 0 0 10px rgba(255,200,0,0.5);
  }
  @keyframes bannerPulse {
    from { transform:scale(1); opacity:0.85; }
    to   { transform:scale(1.06); opacity:1; }
  }
  /* Confetti canvas overlay */
  #confetti-canvas {
    position:absolute; inset:0; z-index:24;
    pointer-events:none; display:none;
  }
  #confetti-canvas.visible { display:block; }
</style>
</head>
<body>

<div id="game-wrap">
  <!-- HUD inside wrap so it scales with canvas -->
  <div id="hud">
    <div class="hud-item">
      <div class="hud-label">Score</div>
      <div class="hud-value" id="score-text">0</div>
    </div>
    <div class="hud-item" style="text-align:center;">
      <div class="hud-label">Best</div>
      <div class="hud-value" id="best-text" style="color:var(--neon-green);text-shadow:0 0 8px rgba(57,255,20,0.5);">0</div>
    </div>
    <div class="hud-item">
      <div class="hud-label">Wave</div>
      <div class="hud-value" id="wave-text">1</div>
    </div>
    <div class="hud-item" style="text-align:right;">
      <div class="hud-label">Lives</div>
      <div id="lives-display"></div>
    </div>
  </div>

  <canvas id="game"></canvas>

  <!-- In-game pause button (mobile only, top-right) -->
  <div id="pause-btn" onclick="togglePause()">
    <svg viewBox="0 0 24 24" fill="none" stroke="var(--neon-cyan)" stroke-width="2.5" stroke-linecap="round">
      <line x1="6" y1="4" x2="6" y2="20"/><line x1="18" y1="4" x2="18" y2="20"/>
    </svg>
  </div>

  <!-- Mobile on-screen controls -->
  <div id="mobile-controls">
    <div id="joystick-area">
      <div id="joystick-base">
        <div id="joystick-stick"></div>
      </div>
    </div>
    <div id="shoot-btn">FIRE</div>
  </div>

  <!-- Confetti canvas (new highscore) -->
  <canvas id="confetti-canvas"></canvas>

  <!-- NEW HIGHSCORE banner -->
  <div id="new-hs-banner">
    <div class="banner-text">NEW BEST!</div>
    <div class="banner-sub">HIGHSCORE</div>
  </div>

  <!-- Menu overlay -->
  <div id="overlay">
    <div id="overlay-panel"></div>
    <div id="overlay-grid"></div>
    <div id="overlay-stripe"></div>
    <div id="overlay-dots"></div>

    <!-- Audio sliders (top-left) -->
    <div id="audio-controls">
      <div class="audio-row">
        <span class="audio-icon">ğŸ”Š</span>
        <div class="audio-slider-wrap" id="music-slider-wrap">
          <div class="audio-slider-track">
            <div class="audio-slider-fill" id="music-fill"></div>
            <div class="audio-slider-thumb" id="music-thumb"></div>
          </div>
        </div>
      </div>
      <div class="audio-row">
        <span class="audio-icon">ğŸ””</span>
        <div class="audio-slider-wrap" id="sfx-slider-wrap">
          <div class="audio-slider-track">
            <div class="audio-slider-fill" id="sfx-fill"></div>
            <div class="audio-slider-thumb" id="sfx-thumb"></div>
          </div>
        </div>
      </div>
    </div>

    <div id="overlay-top">
      <h1 id="overlay-title">STELLAR BLITZ</h1>
      <div class="subtitle" id="overlay-sub">Defend the galaxy</div>
    </div>

    <div id="menu-hs">
      <div class="hs-label">Best Score</div>
      <div class="hs-value" id="menu-hs-value">0</div>
    </div>

    <div id="overlay-bottom">
      <div class="score-row hidden" id="score-row">
        <div class="score-col">
          <div class="s-label">Score</div>
          <div class="s-value" id="overlay-score">0</div>
        </div>
        <div class="score-col">
          <div class="s-label">Best</div>
          <div class="s-value" id="overlay-best">0</div>
        </div>
      </div>
      <div class="btn-row" id="btn-row">
        <!-- buttons injected dynamically by showMenu / showGameOver -->
      </div>
    </div>

    <div id="controls-hint">
      <span class="hint-desktop"><span>â† â†’</span> Move &nbsp; <span>SPACE</span> Shoot &nbsp; <span>ESC</span> Pause</span>
      <span class="hint-mobile">Use joystick to move Â· Fire button to shoot</span>
    </div>
  </div>

  <!-- Pause overlay -->
  <div id="pause-overlay">
    <h2>PAUSED</h2>
    <div class="pause-btn-row">
      <button class="pause-btn" onclick="togglePause()">RESUME</button>
      <button class="pause-btn sec" onclick="showMenu()">MENU</button>
    </div>
  </div>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STELLAR BLITZ â€” Optimised Arcade Shooter
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = 680, H = 720;
canvas.width = W; canvas.height = H;

// â”€â”€â”€ DOM refs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const overlay      = document.getElementById('overlay');
const overlayTitle = document.getElementById('overlay-title');
const overlaySub   = document.getElementById('overlay-sub');
const overlayScore = document.getElementById('overlay-score');
const overlayBest  = document.getElementById('overlay-best');
const scoreRow     = document.getElementById('score-row');
const btnRow       = document.getElementById('btn-row');
const scoreText    = document.getElementById('score-text');
const bestText     = document.getElementById('best-text');
const waveText     = document.getElementById('wave-text');
const livesDisplay = document.getElementById('lives-display');

// â”€â”€â”€ HIGHSCORE (in-memory, persisted via window.storage) â”€â”€
let highScore = 0;
async function loadHighScore() {
  try {
    const r = await window.storage.get('stellarblitz_hs');
    if (r && r.value) highScore = parseInt(r.value, 10) || 0;
  } catch(e) { highScore = 0; }
  bestText.textContent = highScore;
  // Also populate menu panel
  if (document.getElementById('menu-hs-value')) {
    document.getElementById('menu-hs-value').textContent = highScore;
    document.getElementById('menu-hs').classList.add('visible');
  }
}
async function saveHighScore(s) {
  if (s > highScore) {
    highScore = s;
    bestText.textContent = highScore;
    try { await window.storage.set('stellarblitz_hs', String(highScore)); } catch(e){}
  }
}
loadHighScore();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AUDIO SYSTEM â€” Web Audio API
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function initAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  // Music gain
  musicGainNode = audioCtx.createGain();
  musicGainNode.connect(audioCtx.destination);

  // SFX gain
  sfxGainNode = audioCtx.createGain();
  sfxGainNode.connect(audioCtx.destination);

  // Load saved volumes (stored as 0â€“100 integer)
  const savedMV = localStorage.getItem('stellarblitz_music_vol');
  const savedSV = localStorage.getItem('stellarblitz_sfx_vol');
  if (savedMV !== null) { musicVolume = Number(savedMV) / 100 * 0.3; }
  if (savedSV !== null) { sfxVolume   = Number(savedSV) / 100 * 0.3; }
  musicGainNode.gain.value = musicVolume;
  sfxGainNode.gain.value   = sfxVolume;

  // Sync sliders
  syncSliders();
}

function syncSliders() {
  const mPct = Math.round(musicVolume / 0.3 * 100);
  const sPct = Math.round(sfxVolume   / 0.3 * 100);
  const mf = document.getElementById('music-fill'),  mt = document.getElementById('music-thumb');
  const sf = document.getElementById('sfx-fill'),    st = document.getElementById('sfx-thumb');
  
  // Clamp thumb position: at 100%, thumb center is at 100% but half hangs out
  // Thumb is 16px, track is 80px â†’ thumb takes ~20% of track width
  // So max safe left is 100% - 10% = 90% to keep thumb fully inside
  const maxThumbPct = 92; // empirical: keeps 16px thumb inside 80px track
  
  if (mf) mf.style.width = mPct + '%';
  if (mt) mt.style.left  = Math.min(mPct, maxThumbPct) + '%';
  if (sf) sf.style.width = sPct + '%';
  if (st) st.style.left  = Math.min(sPct, maxThumbPct) + '%';
}

// â”€â”€ Custom slider pointer-event wiring â”€â”€
function makeSliderDrag(wrapId, callback) {
  const wrap  = document.getElementById(wrapId);
  if (!wrap) return;
  const track = wrap.querySelector('.audio-slider-track');
  let dragging = false;

  function getVal(e) {
    const rect = track.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    
    // Get pointer position
    let x = e.clientX;
    let y = e.clientY;
    
    // Detect rotation
    const isRotated = window.matchMedia('(max-width: 768px) and (orientation: portrait)').matches;
    
    // Calculate offset from track center
    let dx = x - centerX;
    let dy = y - centerY;
    
    // If rotated, swap axes (slider is horizontal in game space, but vertical in physical space)
    if (isRotated) {
      const temp = dx;
      dx = -dy;
      dy = temp;
    }
    
    // Convert to position along track (left edge to right edge)
    const trackLeft = rect.left;
    let relX = dx + rect.width / 2; // offset from center + half width = offset from left
    
    return Math.max(0, Math.min(100, Math.round(relX / rect.width * 100)));
  }

  wrap.addEventListener('pointerdown', e => {
    e.preventDefault();
    wrap.setPointerCapture(e.pointerId);
    dragging = true;
    initAudio();
    const val = getVal(e);
    callback(val);
    syncSliders();
  });
  wrap.addEventListener('pointermove', e => {
    if (!dragging) return;
    e.preventDefault();
    const val = getVal(e);
    callback(val);
    syncSliders();
  });
  wrap.addEventListener('pointerup',     e => { dragging = false; });
  wrap.addEventListener('pointercancel', e => { dragging = false; });
}

function initCustomSliders() {
  makeSliderDrag('music-slider-wrap', onMusicSlider);
  makeSliderDrag('sfx-slider-wrap',   onSFXSlider);
  syncSliders(); // paint initial positions
}

function onMusicSlider(val) {
  musicVolume = val / 100 * 0.3;
  localStorage.setItem('stellarblitz_music_vol', val);
  if (musicGainNode) musicGainNode.gain.value = musicVolume;
  if (val > 0 && state === 'menu') playMusic();
  if (val <= 0) stopMusic();
}

function onSFXSlider(val) {
  sfxVolume = val / 100 * 0.3;
  localStorage.setItem('stellarblitz_sfx_vol', val);
  if (sfxGainNode) sfxGainNode.gain.value = sfxVolume;
}

// Procedural chill ambient music (slow evolving pads)
let musicGenId = 0; // incremented every stopMusic â€” kills stale playChord chains

function playMusic() {
  initAudio();
  if (musicVolume <= 0) return;

  // Kill any previous chain before starting a new one
  musicGenId++;
  const myGen = musicGenId;
  musicOscillators = [];

  const chordProgression = [
    [220.00, 261.63, 329.63],
    [174.61, 220.00, 261.63],
    [130.81, 164.81, 196.00],
    [196.00, 246.94, 293.66]
  ];
  let chordIndex = 0;

  function playChord() {
    if (myGen !== musicGenId) return;  // stale chain â†’ stop
    if (musicVolume <= 0) return;
    const freqs = chordProgression[chordIndex];
    chordIndex = (chordIndex + 1) % chordProgression.length;
    freqs.forEach((freq, i) => {
      const osc     = audioCtx.createOscillator();
      const gainEnv = audioCtx.createGain();
      osc.type = i === 0 ? 'sine' : 'triangle';
      osc.frequency.value = freq;
      gainEnv.gain.value = 0;
      gainEnv.gain.linearRampToValueAtTime(0.08, audioCtx.currentTime + 1.5);
      gainEnv.gain.linearRampToValueAtTime(0,    audioCtx.currentTime + 8);
      osc.connect(gainEnv);
      gainEnv.connect(musicGainNode);
      osc.start();
      osc.stop(audioCtx.currentTime + 8);
      musicOscillators.push(osc);
    });
    setTimeout(playChord, 8000);
  }
  playChord();
}

function stopMusic() {
  musicGenId++;  // invalidates any running playChord chain
  musicOscillators.forEach(osc => { try { osc.stop(); } catch(e){} });
  musicOscillators = [];
}

// â”€â”€ Sound effects (all routed through sfxGainNode) â”€â”€
function playShootSound() {
  initAudio();
  if (sfxVolume <= 0) return;
  const osc  = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = 'square';
  osc.frequency.value = 800;
  osc.frequency.exponentialRampToValueAtTime(400, audioCtx.currentTime + 0.05);
  gain.gain.value = 0.4; // relative; master controlled by sfxGainNode
  gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);
  osc.connect(gain);
  gain.connect(sfxGainNode);
  osc.start();
  osc.stop(audioCtx.currentTime + 0.05);
}

function playExplosionSound(pitchMult = 1.0) {
  initAudio();
  if (sfxVolume <= 0) return;

  // Noise burst
  const noise       = audioCtx.createBufferSource();
  const noiseBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.3, audioCtx.sampleRate);
  const data        = noiseBuffer.getChannelData(0);
  for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
  noise.buffer = noiseBuffer;

  const noiseFilter = audioCtx.createBiquadFilter();
  noiseFilter.type  = 'lowpass';
  noiseFilter.frequency.value = 300 * pitchMult;

  const noiseGain = audioCtx.createGain();
  noiseGain.gain.value = 0.5;
  noiseGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);

  noise.connect(noiseFilter);
  noiseFilter.connect(noiseGain);
  noiseGain.connect(sfxGainNode);
  noise.start();
  noise.stop(audioCtx.currentTime + 0.3);

  // Rumble
  const rumble     = audioCtx.createOscillator();
  const rumbleGain = audioCtx.createGain();
  rumble.type = 'sine';
  rumble.frequency.value = 60 * pitchMult;
  rumbleGain.gain.value  = 0.6;
  rumbleGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
  rumble.connect(rumbleGain);
  rumbleGain.connect(sfxGainNode);
  rumble.start();
  rumble.stop(audioCtx.currentTime + 0.4);
}

// Rising celebratory jingle for PERFECT WAVE
function playPerfectSound() {
  initAudio();
  if (sfxVolume <= 0) return;
  // E5 â†’ G5 â†’ B5 â†’ E6  â€” bright ascending arp
  const notes = [659.25, 783.99, 987.77, 1318.51];
  notes.forEach((freq, i) => {
    const osc  = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'sine';
    osc.frequency.value = freq;
    const t = audioCtx.currentTime + i * 0.11;
    gain.gain.value = 0;
    gain.gain.linearRampToValueAtTime(0.22, t + 0.025);
    gain.gain.linearRampToValueAtTime(0,    t + 0.25);
    osc.connect(gain);
    gain.connect(sfxGainNode);
    osc.start(t);
    osc.stop(t + 0.28);
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€â”€ OFFSCREEN SPRITE CANVASES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// We pre-render each ship type once, then drawImage() is blazing fast.
function makeCanvas(w, h) {
  const c = document.createElement('canvas');
  c.width = w; c.height = h;
  return c;
}

// â”€â”€ Player ship sprite (detailed fighter) â”€â”€
function renderPlayerSprite() {
  const c = makeCanvas(72, 88);  // 2Ã— size for crispness, drawn at half
  const g = c.getContext('2d');
  g.imageSmoothingEnabled = false;

  // Engine flame
  const flame = g.createRadialGradient(36, 72, 2, 36, 68, 18);
  flame.addColorStop(0, 'rgba(0,240,255,0.9)');
  flame.addColorStop(0.4,'rgba(0,200,255,0.5)');
  flame.addColorStop(1,  'rgba(0,100,180,0)');
  g.fillStyle = flame;
  g.fillRect(20, 58, 32, 28);

  // Wing accents (back fins)
  g.fillStyle = 'rgba(0,240,255,0.15)';
  g.beginPath();
  g.moveTo(36, 10); g.lineTo(68, 78); g.lineTo(52, 72); g.lineTo(36, 40); g.closePath();
  g.fill();
  g.beginPath();
  g.moveTo(36, 10); g.lineTo(4, 78); g.lineTo(20, 72); g.lineTo(36, 40); g.closePath();
  g.fill();

  // Main hull
  g.fillStyle = '#16162e';
  g.beginPath();
  g.moveTo(36, 4);       // nose
  g.lineTo(62, 72);      // right wing tip
  g.lineTo(50, 66);      // right wing inner
  g.lineTo(44, 50);      // right body notch
  g.lineTo(44, 38);      // right neck
  g.lineTo(36, 34);      // center
  g.lineTo(28, 38);      // left neck
  g.lineTo(28, 50);      // left body notch
  g.lineTo(22, 66);      // left wing inner
  g.lineTo(10, 72);      // left wing tip
  g.closePath();
  g.fill();

  // Hull outline â€” cyan glow
  g.strokeStyle = '#00f0ff';
  g.lineWidth = 2;
  g.shadowColor = '#00f0ff';
  g.shadowBlur = 8;
  g.stroke();
  g.shadowBlur = 0;

  // Wing stripe details
  g.strokeStyle = 'rgba(0,240,255,0.4)';
  g.lineWidth = 1;
  g.beginPath(); g.moveTo(18,56); g.lineTo(28,50); g.stroke();
  g.beginPath(); g.moveTo(54,56); g.lineTo(44,50); g.stroke();
  // Center line
  g.strokeStyle = 'rgba(0,240,255,0.3)';
  g.beginPath(); g.moveTo(36,12); g.lineTo(36,32); g.stroke();

  // Cockpit
  g.fillStyle = 'rgba(0,240,255,0.2)';
  g.strokeStyle = 'rgba(0,240,255,0.6)';
  g.lineWidth = 1.5;
  g.beginPath();
  g.ellipse(36, 24, 5, 9, 0, 0, Math.PI*2);
  g.fill(); g.stroke();

  // Cockpit highlight
  g.fillStyle = 'rgba(180,240,255,0.35)';
  g.beginPath();
  g.ellipse(34, 21, 2.5, 5, -0.2, 0, Math.PI*2);
  g.fill();

  // Wing tip LEDs
  g.fillStyle = '#00f0ff';
  g.shadowColor = '#00f0ff'; g.shadowBlur = 5;
  g.beginPath(); g.arc(11, 71, 2, 0, Math.PI*2); g.fill();
  g.beginPath(); g.arc(61, 71, 2, 0, Math.PI*2); g.fill();
  g.shadowBlur = 0;

  return c;
}

// â”€â”€ Enemy Type 0: Pink Raider (wide, aggressive) â”€â”€
function renderEnemy0() {
  const c = makeCanvas(64, 56);
  const g = c.getContext('2d');

  // Body glow bg
  g.fillStyle = 'rgba(255,45,123,0.08)';
  g.beginPath(); g.ellipse(32, 28, 30, 26, 0, 0, Math.PI*2); g.fill();

  // Hull
  g.fillStyle = '#1e1028';
  g.beginPath();
  g.moveTo(32, 48);      // bottom point
  g.lineTo(58, 16);      // right wing
  g.lineTo(52, 10);      // right wing top
  g.lineTo(42, 18);      // right notch
  g.lineTo(36, 14);      // center top right
  g.lineTo(32, 16);      // nose
  g.lineTo(28, 14);      // center top left
  g.lineTo(22, 18);      // left notch
  g.lineTo(12, 10);      // left wing top
  g.lineTo(6, 16);       // left wing
  g.closePath();
  g.fill();

  g.strokeStyle = '#ff2d7b';
  g.lineWidth = 2;
  g.shadowColor = '#ff2d7b'; g.shadowBlur = 7;
  g.stroke(); g.shadowBlur = 0;

  // Wing lines
  g.strokeStyle = 'rgba(255,45,123,0.35)'; g.lineWidth = 1;
  g.beginPath(); g.moveTo(14,18); g.lineTo(22,30); g.stroke();
  g.beginPath(); g.moveTo(50,18); g.lineTo(42,30); g.stroke();
  g.beginPath(); g.moveTo(32,16); g.lineTo(32,38); g.stroke();

  // "Eyes" â€” two glowing dots
  g.fillStyle = '#ff6699';
  g.shadowColor = '#ff2d7b'; g.shadowBlur = 4;
  g.beginPath(); g.arc(26, 22, 2.5, 0, Math.PI*2); g.fill();
  g.beginPath(); g.arc(38, 22, 2.5, 0, Math.PI*2); g.fill();
  g.shadowBlur = 0;

  return c;
}

// â”€â”€ Enemy Type 1: Purple Tank (bulky, 2HP) â”€â”€
function renderEnemy1() {
  const c = makeCanvas(72, 64);
  const g = c.getContext('2d');

  // Glow
  g.fillStyle = 'rgba(168,85,247,0.07)';
  g.beginPath(); g.ellipse(36, 32, 34, 30, 0, 0, Math.PI*2); g.fill();

  // Main hull â€” boxy
  g.fillStyle = '#1a1030';
  g.beginPath();
  g.moveTo(36, 52);
  g.lineTo(64, 24); g.lineTo(60, 12); g.lineTo(48, 8);
  g.lineTo(36, 12); g.lineTo(24, 8); g.lineTo(12, 12);
  g.lineTo(8, 24); g.lineTo(36, 52);
  g.closePath();
  g.fill();

  g.strokeStyle = '#a855f7'; g.lineWidth = 2;
  g.shadowColor = '#a855f7'; g.shadowBlur = 8;
  g.stroke(); g.shadowBlur = 0;

  // Armor plates
  g.strokeStyle = 'rgba(168,85,247,0.3)'; g.lineWidth = 1;
  g.beginPath(); g.moveTo(20,18); g.lineTo(36,30); g.stroke();
  g.beginPath(); g.moveTo(52,18); g.lineTo(36,30); g.stroke();
  g.beginPath(); g.moveTo(36,12); g.lineTo(36,42); g.stroke();
  // Horizontal band
  g.beginPath(); g.moveTo(16,26); g.lineTo(56,26); g.stroke();

  // Core reactor â€” glowing center
  g.fillStyle = 'rgba(168,85,247,0.35)';
  g.strokeStyle = '#a855f7'; g.lineWidth = 1;
  g.beginPath(); g.arc(36, 28, 5, 0, Math.PI*2); g.fill(); g.stroke();
  g.fillStyle = 'rgba(200,160,255,0.6)';
  g.beginPath(); g.arc(36, 27, 2, 0, Math.PI*2); g.fill();

  // Wing tip lights
  g.fillStyle = '#c084fc';
  g.shadowColor = '#a855f7'; g.shadowBlur = 4;
  g.beginPath(); g.arc(10, 22, 2, 0, Math.PI*2); g.fill();
  g.beginPath(); g.arc(62, 22, 2, 0, Math.PI*2); g.fill();
  g.shadowBlur = 0;

  return c;
}

// â”€â”€ Enemy Type 2: Orange Striker (sleek, fast-looking) â”€â”€
function renderEnemy2() {
  const c = makeCanvas(56, 76);
  const g = c.getContext('2d');

  // Glow
  g.fillStyle = 'rgba(249,115,22,0.08)';
  g.beginPath(); g.ellipse(28, 38, 26, 36, 0, 0, Math.PI*2); g.fill();

  // Elongated hull
  g.fillStyle = '#1e1810';
  g.beginPath();
  g.moveTo(28, 64);      // bottom tip
  g.lineTo(46, 34);      // right sweep
  g.lineTo(44, 18);      // right shoulder
  g.lineTo(38, 10);      // right neck
  g.lineTo(28, 6);       // top nose
  g.lineTo(18, 10);      // left neck
  g.lineTo(14, 18);      // left shoulder
  g.lineTo(12, 34);      // left sweep
  g.closePath();
  g.fill();

  g.strokeStyle = '#f97316'; g.lineWidth = 2;
  g.shadowColor = '#f97316'; g.shadowBlur = 7;
  g.stroke(); g.shadowBlur = 0;

  // Speed lines
  g.strokeStyle = 'rgba(249,115,22,0.3)'; g.lineWidth = 1;
  g.beginPath(); g.moveTo(18,30); g.lineTo(22,44); g.stroke();
  g.beginPath(); g.moveTo(38,30); g.lineTo(34,44); g.stroke();
  g.beginPath(); g.moveTo(28,12); g.lineTo(28,50); g.stroke();

  // Cockpit slit
  g.fillStyle = 'rgba(249,115,22,0.25)';
  g.strokeStyle = '#f97316'; g.lineWidth = 1;
  g.beginPath(); g.ellipse(28, 24, 4, 8, 0, 0, Math.PI*2); g.fill(); g.stroke();

  // Nose flame
  const nf = g.createRadialGradient(28, 62, 1, 28, 60, 8);
  nf.addColorStop(0, 'rgba(249,115,22,0.7)');
  nf.addColorStop(0.5,'rgba(249,115,22,0.3)');
  nf.addColorStop(1,  'rgba(249,115,22,0)');
  g.fillStyle = nf;
  g.fillRect(22, 56, 12, 14);

  // Wing tip lights
  g.fillStyle = '#fb923c';
  g.shadowColor = '#f97316'; g.shadowBlur = 4;
  g.beginPath(); g.arc(13, 33, 1.8, 0, Math.PI*2); g.fill();
  g.beginPath(); g.arc(43, 33, 1.8, 0, Math.PI*2); g.fill();
  g.shadowBlur = 0;

  return c;
}

// Pre-render all sprites once
const SPRITE = {
  player: renderPlayerSprite(),
  enemy0: renderEnemy0(),
  enemy1: renderEnemy1(),
  enemy2: renderEnemy2()
};

// â”€â”€â”€ CACHED BACKGROUND â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const bgCanvas = makeCanvas(W, H);
(function cacheBG() {
  const g = bgCanvas.getContext('2d');
  const grad = g.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#050510');
  grad.addColorStop(0.5, '#0a0a1a');
  grad.addColorStop(1, '#0d0d22');
  g.fillStyle = grad;
  g.fillRect(0, 0, W, H);
})();

// â”€â”€â”€ STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let state = 'menu'; // menu | playing | paused | gameover
let paused = false;
let score = 0, wave = 0, lives = 4; // 4 lives instead of 3
let player, bullets, enemies, enemyBullets, particles, stars, explosions;
let keys = {};
let touchMoveX = null;
let touchShoot = false; // right-side tap = shoot
let waveDelay = 0;
let lastTime = 0;

// Anti-camping: track player position to detect camping
let playerLastX = 0;
let playerStillFrames = 0;

// Death tracking
let deathReason = '';        // final cause of game over
let liveLog = [];            // array of strings: how each life was lost

// Perfect-wave banner
let livesAtWaveStart = 4;    // snapshot when wave spawns
let perfectTimer = 0;        // frames left for PERFECT WAVE banner (100 â‰ˆ 1.6 s)

// Visual effects timers
let muzzleFlashTimer = 0;    // frames left for muzzle flash (3 frames)
let waveFlashTimer = 0;      // frames left for "WAVE N" big flash (90 frames)
let waveFlashNumber = 0;     // which wave number to show

// Audio system
let audioCtx;
let musicGainNode;
let sfxGainNode;
let musicVolume = 0.15;   // default music volume (0â€“0.3 range mapped from slider 0â€“100)
let sfxVolume   = 0.18;   // default sfx volume
let musicOscillators = [];

// Joystick state (mobile)
let joystickActive = false;
let joystickDeltaX = 0;

const pauseOverlay = document.getElementById('pause-overlay');
const pauseBtnEl   = document.getElementById('pause-btn');
const confettiCanvas = document.getElementById('confetti-canvas');
const confettiCtx  = confettiCanvas.getContext('2d');
const newHsBanner  = document.getElementById('new-hs-banner');
const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

// â”€â”€â”€ MENU BG ANIMATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const menuHsEl    = document.getElementById('menu-hs');
const menuHsValue = document.getElementById('menu-hs-value');

// Nebula clouds â€” big soft radial blobs that drift
const NEBULAE = [
  { cx: 120, cy: 200, r: 220, color: 'rgba(0,60,120,',  vx: 0.18, vy: 0.06 },
  { cx: 500, cy: 500, r: 180, color: 'rgba(80,20,100,', vx:-0.12, vy: 0.09 },
  { cx: 340, cy: 100, r: 160, color: 'rgba(20,80,100,', vx: 0.06, vy: 0.14 },
  { cx: 60,  cy: 550, r: 200, color: 'rgba(60,10,80,',  vx: 0.22, vy:-0.07 },
  { cx: 620, cy: 180, r: 150, color: 'rgba(10,50,90,',  vx:-0.09, vy: 0.11 }
];

// Drifting enemy formation â€” a V-shape of enemy sprites that slowly fly across
let menuShips = [];
function resetMenuShips() {
  menuShips = [];
  // Leader
  menuShips.push({ spriteKey:'enemy1', x: -80, y: 340, vx: 1.1, vy: 0.0, scale: 1.6 });
  // Left wing
  menuShips.push({ spriteKey:'enemy0', x:-110, y: 290, vx: 1.1, vy:-0.02, scale: 1.2 });
  menuShips.push({ spriteKey:'enemy2', x:-140, y: 255, vx: 1.1, vy:-0.04, scale: 1.0 });
  // Right wing
  menuShips.push({ spriteKey:'enemy0', x:-110, y: 390, vx: 1.1, vy: 0.02, scale: 1.2 });
  menuShips.push({ spriteKey:'enemy2', x:-140, y: 425, vx: 1.1, vy: 0.04, scale: 1.0 });
}
resetMenuShips();

// â”€â”€â”€ STARS (init once) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function initStars() {
  stars = [];
  for (let i = 0; i < 140; i++) {
    stars.push({
      x: Math.random() * W,
      y: Math.random() * H,
      r: Math.random() * 1.6 + 0.3,
      speed: Math.random() * 1.0 + 0.25,
      phase: Math.random() * Math.PI * 2
    });
  }
}

// â”€â”€â”€ PLAYER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function createPlayer() {
  return { x: W/2, y: H-80, w: 36, h: 44, cooldown: 0, invulnerable: 150 }; // 150 frames invuln
}

// â”€â”€â”€ ENEMY TYPES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const ENEMY_DEFS = [
  { spriteKey:'enemy0', w:32, h:28, color:'#ff2d7b', baseHp:1, pts:100, shootRate:0.003 }, // reduced from 0.004
  { spriteKey:'enemy1', w:36, h:32, color:'#a855f7', baseHp:2, pts:200, shootRate:0.002 }, // reduced from 0.003
  { spriteKey:'enemy2', w:28, h:38, color:'#f97316', baseHp:1, pts:150, shootRate:0.004 }  // reduced from 0.006
];

function spawnWave() {
  wave++;
  waveText.textContent = wave;
  livesAtWaveStart = lives;  // snapshot for perfect-wave check
  
  // Trigger big "WAVE N" flash on screen
  waveFlashTimer = 90;
  waveFlashNumber = wave;
  const cols = wave === 1 ? 6 : (wave === 2 ? 7 : 8 + Math.min(wave - 2, 4)); // fewer enemies early
  const rows = wave === 1 ? 2 : 2 + Math.min(Math.floor((wave - 1) / 2), 3);
  const marginX = 50;
  const gapX = (W - marginX * 2) / (cols - 1 || 1);
  const startY = 60, gapY = 48;

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const typeIdx = Math.min(r, ENEMY_DEFS.length - 1);
      const d = ENEMY_DEFS[typeIdx];
      const hp = d.baseHp + Math.floor(wave / 5); // slower HP scaling (was /4)
      enemies.push({
        x: marginX + c * gapX,
        y: startY + r * gapY,
        w: d.w, h: d.h,
        spriteKey: d.spriteKey,
        color: d.color,
        hp, maxHp: hp,
        pts: d.pts,
        shootRate: d.shootRate * (1 + wave * 0.03), // slower rate scaling (was 0.05)
        dx: (wave % 2 === 0 ? -1 : 1) * (0.5 + wave * 0.06), // slower speed (was 0.6 + 0.08)
        dy: 0.12 + wave * 0.015, // slower descent (was 0.15 + 0.02)
        alive: true
      });
    }
  }
}

// â”€â”€â”€ PARTICLES (pooled) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const MAX_PARTICLES = 400;
let particlePool = new Array(MAX_PARTICLES);
let particleCount = 0;
for (let i = 0; i < MAX_PARTICLES; i++) particlePool[i] = { active: false };

function explode(x, y, color, count, speed) {
  for (let i = 0; i < count && particleCount < MAX_PARTICLES; i++) {
    const angle = (Math.PI * 2 * i) / count + Math.random() * 0.5;
    const s = speed * (0.5 + Math.random());
    // Find a free slot
    for (let j = 0; j < MAX_PARTICLES; j++) {
      if (!particlePool[j].active) {
        particlePool[j] = {
          active: true, x, y,
          vx: Math.cos(angle) * s,
          vy: Math.sin(angle) * s,
          life: 38 + (Math.random() * 20) | 0,
          maxLife: 58,
          color,
          r: 2 + Math.random() * 2.5
        };
        particleCount++;
        break;
      }
    }
  }
}

function addExplosion(x, y, color) {
  explosions.push({ x, y, color, life: 16, maxLife: 16 });
}

// â”€â”€â”€ SHOOTING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function playerShoot() {
  if (player.cooldown > 0) return;
  player.cooldown = 8; // faster shooting (was 11)
  bullets.push({ x: player.x, y: player.y - 22, vy: -13, color: '#00f0ff', w: 3, h: 15 });
  muzzleFlashTimer = 3; // trigger muzzle flash
  playShootSound();
}

function enemyShoot(e) {
  enemyBullets.push({ x: e.x, y: e.y + e.h/2, vy: 5 + wave * 0.28, color: '#ff4466', w: 3, h: 12 });
}

// â”€â”€â”€ COLLISION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function overlap(ax, ay, aw, ah, bx, by, bw, bh) {
  return ax - aw/2 < bx + bw/2 && ax + aw/2 > bx - bw/2 &&
         ay - ah/2 < by + bh/2 && ay + ah/2 > by - bh/2;
}

// â”€â”€â”€ LIVES UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateLives() {
  livesDisplay.innerHTML = '';
  for (let i = 0; i < lives; i++) livesDisplay.innerHTML += '<div class="life-icon"></div>';
}

// â”€â”€â”€ GAME OVER OVERLAY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showGameOver() {
  pauseBtnEl.classList.remove('visible');
  const isNewBest = score > highScore;
  saveHighScore(score);

  overlayTitle.textContent = 'GAME OVER';
  overlaySub.textContent   = deathReason || 'You have fallen';
  overlayScore.textContent = score;
  overlayBest.textContent  = highScore;
  scoreRow.classList.remove('hidden');

  btnRow.innerHTML = '';

  // â”€â”€ Life log card â”€â”€
  if (liveLog.length > 0) {
    const card = document.createElement('div');
    card.className = 'death-log';

    const title = document.createElement('div');
    title.className = 'death-log-title';
    title.textContent = 'How you died';
    card.appendChild(title);

    const icons = { bullet:'ğŸ’¥', collision:'ğŸ’¥', unknown:'âš ï¸' };

    liveLog.forEach((entry, idx) => {
      const row = document.createElement('div');
      row.className = 'death-log-entry';

      const num = document.createElement('span');
      num.className = 'log-num';
      num.textContent = '#' + (idx + 1);

      const icon = document.createElement('span');
      icon.className = 'log-icon';
      icon.textContent = icons[entry.type] || 'âš ï¸';

      const text = document.createElement('span');
      text.className = 'log-text';
      text.textContent = entry.reason;

      const wave_badge = document.createElement('span');
      wave_badge.style.cssText = 'font-size:8px;color:rgba(0,100,160,0.5);'
        + 'background:rgba(0,100,160,0.1);padding:2px 6px;border-radius:4px;'
        + 'letter-spacing:1px;flex-shrink:0;';
      wave_badge.textContent = 'W' + entry.wave;

      row.appendChild(num);
      row.appendChild(icon);
      row.appendChild(text);
      row.appendChild(wave_badge);
      card.appendChild(row);
    });

    btnRow.appendChild(card);
  }

  const actionsRow = document.createElement('div');
  actionsRow.className = 'btn-actions';

  const playBtn = document.createElement('button');
  playBtn.className = 'btn';
  playBtn.textContent = 'PLAY AGAIN';
  playBtn.onclick = startGame;
  actionsRow.appendChild(playBtn);

  const menuBtn = document.createElement('button');
  menuBtn.className = 'btn secondary';
  menuBtn.textContent = 'MENU';
  menuBtn.onclick = showMenu;
  actionsRow.appendChild(menuBtn);

  btnRow.appendChild(actionsRow);

  overlay.classList.remove('hidden');

  if (isNewBest) triggerNewHighscore();
}

// â”€â”€ Confetti system â”€â”€
let confettiPieces = [];
let confettiAnimId = null;

function triggerNewHighscore() {
  // Size confetti canvas to match game-wrap
  const wrap = document.getElementById('game-wrap');
  const r = wrap.getBoundingClientRect();
  confettiCanvas.width  = r.width;
  confettiCanvas.height = r.height;
  confettiCanvas.classList.add('visible');
  newHsBanner.classList.add('visible');

  // Spawn confetti
  confettiPieces = [];
  const colors = ['#ffe600','#ff2d7b','#00f0ff','#39ff14','#a855f7','#f97316','#fff'];
  for (let i = 0; i < 120; i++) {
    confettiPieces.push({
      x: Math.random() * confettiCanvas.width,
      y: -Math.random() * confettiCanvas.height * 0.4,
      w: 6 + Math.random() * 6,
      h: 4 + Math.random() * 3,
      color: colors[Math.floor(Math.random() * colors.length)],
      vx: (Math.random() - 0.5) * 3,
      vy: 2.5 + Math.random() * 3,
      rot: Math.random() * Math.PI * 2,
      rotV: (Math.random() - 0.5) * 0.25,
      life: 1
    });
  }

  // Play a celebratory arpeggio sound
  playConfettiSound();

  if (confettiAnimId) cancelAnimationFrame(confettiAnimId);
  animateConfetti();
}

function animateConfetti() {
  confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);

  let anyAlive = false;
  for (let i = 0; i < confettiPieces.length; i++) {
    const p = confettiPieces[i];
    p.x  += p.vx;
    p.y  += p.vy;
    p.rot += p.rotV;
    p.vx *= 0.995; // tiny drag

    // Fade out once past bottom
    if (p.y > confettiCanvas.height) {
      p.life -= 0.04;
    }
    if (p.life <= 0) continue;
    anyAlive = true;

    confettiCtx.save();
    confettiCtx.translate(p.x, p.y);
    confettiCtx.rotate(p.rot);
    confettiCtx.globalAlpha = p.life;
    confettiCtx.fillStyle = p.color;
    confettiCtx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
    confettiCtx.restore();
  }

  if (anyAlive) {
    confettiAnimId = requestAnimationFrame(animateConfetti);
  } else {
    // All gone â€” hide after a beat
    setTimeout(() => {
      confettiCanvas.classList.remove('visible');
      newHsBanner.classList.remove('visible');
    }, 600);
  }
}

function playConfettiSound() {
  initAudio();
  if (sfxVolume <= 0) return;
  const notes = [523.25, 659.25, 783.99, 1046.50];
  notes.forEach((freq, i) => {
    const osc  = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'sine';
    osc.frequency.value = freq;
    const t = audioCtx.currentTime + i * 0.12;
    gain.gain.value = 0;
    gain.gain.linearRampToValueAtTime(0.5, t + 0.04);
    gain.gain.linearRampToValueAtTime(0,   t + 0.35);
    osc.connect(gain);
    gain.connect(sfxGainNode);
    osc.start(t);
    osc.stop(t + 0.4);
  });
}

function showMenu() {
  pauseOverlay.classList.remove('visible');
  pauseBtnEl.classList.remove('visible');
  newHsBanner.classList.remove('visible');
  confettiCanvas.classList.remove('visible');
  paused = false;
  overlayTitle.textContent = 'STELLAR BLITZ';
  overlaySub.textContent = 'Defend the galaxy';
  scoreRow.classList.add('hidden');

  btnRow.innerHTML = '';
  const sb = document.createElement('button');
  sb.className = 'btn';
  sb.id = 'start-btn';
  sb.textContent = 'START GAME';
  sb.onclick = startGame;
  btnRow.appendChild(sb);

  // Show highscore in menu
  menuHsValue.textContent = highScore;
  menuHsEl.classList.add('visible');

  resetMenuShips();
  overlay.classList.remove('hidden');
  state = 'menu';
  touchMoveX = null;
  touchShoot = false;
  joystickActive = false;
  joystickDeltaX = 0;
  
  // Start ambient music
  if (musicVolume > 0) playMusic();
  syncSliders();
}

// â”€â”€â”€ UPDATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function update(dt) {
  // Stars parallax
  for (let i = 0; i < stars.length; i++) {
    const s = stars[i];
    s.y += s.speed;
    if (s.y > H) { s.y = 0; s.x = Math.random() * W; }
  }

  if (state !== 'playing') return;

  // Player move
  const spd = 5.5;
  if (keys['ArrowLeft'] || keys['KeyA']) player.x -= spd;
  if (keys['ArrowRight'] || keys['KeyD']) player.x += spd;
  
  // Joystick input (mobile)
  if (joystickActive) {
    player.x += joystickDeltaX * spd;
  }
  
  player.x = Math.max(player.w/2, Math.min(W - player.w/2, player.x));
  if (keys['Space'] || touchShoot) playerShoot();
  if (player.cooldown > 0) player.cooldown--;
  if (player.invulnerable > 0) player.invulnerable--;

  // Bullets
  for (let i = bullets.length - 1; i >= 0; i--) {
    bullets[i].y += bullets[i].vy;
    if (bullets[i].y < -20) bullets.splice(i, 1);
  }
  // Enemy bullets
  for (let i = enemyBullets.length - 1; i >= 0; i--) {
    enemyBullets[i].y += enemyBullets[i].vy;
    if (enemyBullets[i].y > H + 20) enemyBullets.splice(i, 1);
  }

  // Enemy move + shoot
  let hitEdge = false;
  const isCamping = playerStillFrames > 150; // increased from 120 to be more forgiving
  
  for (let i = 0; i < enemies.length; i++) {
    const e = enemies[i];
    if (!e.alive) continue;
    e.x += e.dx;
    e.y += e.dy;
    if (e.x + e.w/2 > W - 10 || e.x - e.w/2 < 10) hitEdge = true;
    
    // BREACH CHECK â€” if enemy reaches player level, instant game over
    if (e.y > player.y - 10) {
      deathReason = 'The enemy line reached you';
      liveLog.push({ reason: 'Enemy formation breached your line', type: 'breach', wave: wave });
      lives = 0;
      state = 'gameover';
      explode(player.x, player.y, '#00f0ff', 28, 4.5);
      addExplosion(player.x, player.y, '#00f0ff');
      playExplosionSound(1.2);
      setTimeout(showGameOver, 1100);
      return;
    }
    
    // Normal shoot rate + focused fire when camping (reduced multipliers)
    let shootChance = e.shootRate * 1.0; // normal base rate (was 1.5Ã—)
    if (isCamping) {
      const distToPlayer = Math.abs(e.x - player.x);
      if (distToPlayer < 120) shootChance *= 2; // 2Ã— if close (was 3Ã—)
    }
    if (Math.random() < shootChance) enemyShoot(e);
  }
  if (hitEdge) {
    for (let i = 0; i < enemies.length; i++) {
      if (!enemies[i].alive) continue;
      enemies[i].dx *= -1;
      enemies[i].y += 12;
    }
  }

  // Bullet â†” Enemy
  for (let bi = bullets.length - 1; bi >= 0; bi--) {
    const b = bullets[bi];
    for (let ei = 0; ei < enemies.length; ei++) {
      const e = enemies[ei];
      if (!e.alive) continue;
      if (overlap(b.x, b.y, b.w, b.h, e.x, e.y, e.w, e.h)) {
        e.hp--;
        bullets.splice(bi, 1);
        if (e.hp <= 0) {
          e.alive = false;
          score += e.pts * wave;
          scoreText.textContent = score;
          explode(e.x, e.y, e.color, 16, 3.2);
          addExplosion(e.x, e.y, e.color);
          playExplosionSound(1.0);
        } else {
          explode(e.x, e.y, '#fff', 4, 1.2);
        }
        break;
      }
    }
  }

  // Enemy bullets â†” Player
  if (player.invulnerable <= 0) {
    for (let i = enemyBullets.length - 1; i >= 0; i--) {
      const b = enemyBullets[i];
      if (overlap(b.x, b.y, b.w, b.h, player.x, player.y, player.w, player.h)) {
        enemyBullets.splice(i, 1);
        playerHit('Hit by enemy fire', 'bullet');
        break;
      }
    }
  }

  // Enemy â†” Player body collision
  if (player.invulnerable <= 0) {
    for (let i = 0; i < enemies.length; i++) {
      const e = enemies[i];
      if (!e.alive) continue;
      if (overlap(e.x, e.y, e.w, e.h, player.x, player.y, player.w, player.h)) {
        e.alive = false;
        score += e.pts * wave;
        scoreText.textContent = score;
        explode(e.x, e.y, e.color, 10, 2.5);
        addExplosion(e.x, e.y, e.color);
        playExplosionSound(0.9);
        playerHit('Collided with an enemy', 'collision');
        break;
      }
    }
  }

  // Clean dead enemies
  enemies = enemies.filter(e => e.alive);

  // Particles update
  particleCount = 0;
  for (let i = 0; i < MAX_PARTICLES; i++) {
    const p = particlePool[i];
    if (!p.active) continue;
    p.x += p.vx; p.y += p.vy;
    p.vx *= 0.968; p.vy *= 0.968;
    p.life--;
    if (p.life <= 0) { p.active = false; } else { particleCount++; }
  }

  // Explosions
  for (let i = explosions.length - 1; i >= 0; i--) {
    explosions[i].life--;
    if (explosions[i].life <= 0) explosions.splice(i, 1);
  }

  // Next wave
  if (enemies.length === 0 && state === 'playing') {
    if (waveDelay === 0 && wave > 0) {
      // First frame after last enemy died â€” check perfect
      if (lives === livesAtWaveStart) {
        score += 500;
        scoreText.textContent = score;
        perfectTimer = 100;
        playPerfectSound();
      }
    }
    waveDelay++;
    if (waveDelay > 80) { spawnWave(); waveDelay = 0; }
  }
  if (perfectTimer > 0) perfectTimer--;
  if (muzzleFlashTimer > 0) muzzleFlashTimer--;
  if (waveFlashTimer > 0) waveFlashTimer--;

  // Anti-camping tracker
  if (Math.abs(player.x - playerLastX) < 2) {
    playerStillFrames++;
  } else {
    playerStillFrames = 0;
  }
  playerLastX = player.x;
}

function playerHit(reason, type) {
  lives--;
  liveLog.push({ reason: reason || 'Unknown', type: type || 'unknown', wave: wave });
  updateLives();
  explode(player.x, player.y, '#00f0ff', 20, 3.8);
  addExplosion(player.x, player.y, '#00f0ff');
  playExplosionSound(0.8);
  if (lives <= 0) {
    deathReason = reason || 'Unknown cause';
    state = 'gameover';
    setTimeout(showGameOver, 1100);
  } else {
    player.invulnerable = 180;
  }
}

// â”€â”€â”€ DRAW â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function draw(time) {
  // Background (cached image â€” one fillRect)
  ctx.drawImage(bgCanvas, 0, 0);

  // Stars (no shadow, just alpha + fillRect for speed)
  ctx.fillStyle = '#fff';
  for (let i = 0; i < stars.length; i++) {
    const s = stars[i];
    const a = 0.25 + 0.4 * (0.5 + 0.5 * Math.sin(time * 0.0018 + s.phase));
    ctx.globalAlpha = a;
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  // â”€â”€ MENU BACKGROUND â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (state === 'menu') {
    // Nebula clouds â€” drifting soft radial blobs
    for (let i = 0; i < NEBULAE.length; i++) {
      const n = NEBULAE[i];
      // Drift with wrap
      n.cx += n.vx; n.cy += n.vy;
      if (n.cx > W + n.r) n.cx = -n.r;
      if (n.cx < -n.r) n.cx = W + n.r;
      if (n.cy > H + n.r) n.cy = -n.r;
      if (n.cy < -n.r) n.cy = H + n.r;

      // Pulsing alpha
      const pulse = 0.28 + 0.08 * Math.sin(time * 0.0009 + i * 1.3);
      const g = ctx.createRadialGradient(n.cx, n.cy, 0, n.cx, n.cy, n.r);
      g.addColorStop(0,   n.color + pulse + ')');
      g.addColorStop(0.5, n.color + (pulse * 0.4) + ')');
      g.addColorStop(1,   n.color + '0)');
      ctx.fillStyle = g;
      ctx.fillRect(n.cx - n.r, n.cy - n.r, n.r * 2, n.r * 2);
    }

    // Drifting enemy ship formation
    let allGone = true;
    for (let i = 0; i < menuShips.length; i++) {
      const s = menuShips[i];
      s.x += s.vx;
      s.y += s.vy;
      if (s.x < W + 100) allGone = false;

      const spr = SPRITE[s.spriteKey];
      const sw = (spr.width / 2) * s.scale;
      const sh = (spr.height / 2) * s.scale;
      ctx.save();
      ctx.globalAlpha = 0.75;
      ctx.drawImage(spr, s.x - sw/2, s.y - sh/2, sw, sh);
      ctx.restore();
    }
    if (allGone) resetMenuShips();
  }
  for (let i = 0; i < explosions.length; i++) {
    const e = explosions[i];
    const a = e.life / e.maxLife;
    const r = (1 - a) * 38;
    ctx.save();
    ctx.globalAlpha = a * 0.55;
    ctx.shadowColor = e.color; ctx.shadowBlur = 18;
    ctx.strokeStyle = e.color; ctx.lineWidth = 2.5;
    ctx.beginPath(); ctx.arc(e.x, e.y, r, 0, Math.PI*2); ctx.stroke();
    ctx.globalAlpha = a * 0.18;
    ctx.fillStyle = e.color;
    ctx.beginPath(); ctx.arc(e.x, e.y, r*0.45, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }

  // Particles (batch, minimal shadow)
  for (let i = 0; i < MAX_PARTICLES; i++) {
    const p = particlePool[i];
    if (!p.active) continue;
    const a = p.life / p.maxLife;
    ctx.globalAlpha = a;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r * a, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  if (state === 'playing' || state === 'gameover') {
    // Player bullets (glow via shadow, batched)
    ctx.shadowColor = '#00f0ff'; ctx.shadowBlur = 7;
    ctx.fillStyle = '#00f0ff';
    for (let i = 0; i < bullets.length; i++) {
      const b = bullets[i];
      ctx.fillRect(b.x - b.w/2, b.y - b.h/2, b.w, b.h);
    }
    ctx.shadowBlur = 0;

    // Enemy bullets
    ctx.shadowColor = '#ff4466'; ctx.shadowBlur = 6;
    ctx.fillStyle = '#ff4466';
    for (let i = 0; i < enemyBullets.length; i++) {
      const b = enemyBullets[i];
      ctx.fillRect(b.x - b.w/2, b.y - b.h/2, b.w, b.h);
    }
    ctx.shadowBlur = 0;

    // Enemies (drawImage from sprite â€” very fast)
    for (let i = 0; i < enemies.length; i++) {
      const e = enemies[i];
      if (!e.alive) continue;
      const spr = SPRITE[e.spriteKey];
      // Draw sprite centered on enemy pos
      const sw = spr.width / 2, sh = spr.height / 2; // sprites are 2Ã— so draw at half
      ctx.drawImage(spr, e.x - sw/2, e.y - sh/2, sw, sh);

      // HP bar (only if damaged)
      if (e.hp < e.maxHp) {
        const bw = e.w + 4;
        const bx = e.x - bw/2;
        const by = e.y - e.h/2 - 9;
        ctx.fillStyle = 'rgba(0,0,0,0.55)';
        ctx.fillRect(bx, by, bw, 4);
        ctx.fillStyle = e.color;
        ctx.fillRect(bx, by, bw * (e.hp / e.maxHp), 4);
      }
    }

    // Player ship
    if (lives > 0) {
      if (!(player.invulnerable > 0 && ((player.invulnerable / 3)|0) % 2 === 0)) {
        const spr = SPRITE.player;
        const sw = spr.width / 2, sh = spr.height / 2;
        ctx.drawImage(spr, player.x - sw/2, player.y - sh/2, sw, sh);
      }
    }

    // â”€â”€ PERFECT WAVE banner â”€â”€
    if (perfectTimer > 0) {
      // Ease: fade in first 18 frames, hold, fade out last 18 frames
      let a = 1;
      if (perfectTimer > 82) a = (100 - perfectTimer) / 18;
      if (perfectTimer < 18) a = perfectTimer / 18;

      ctx.save();
      ctx.globalAlpha = a;

      // Dark pill bg
      const bw = 300, bh = 62, bx = (W - bw) / 2, by = (H - bh) / 2;
      ctx.fillStyle = 'rgba(4,4,16,0.75)';
      ctx.beginPath();
      ctx.roundRect(bx, by, bw, bh, 8);
      ctx.fill();
      ctx.strokeStyle = 'rgba(57,255,20,0.5)';
      ctx.lineWidth = 1.5;
      ctx.stroke();

      // Glow + text
      ctx.shadowColor = 'rgba(57,255,20,0.55)';
      ctx.shadowBlur  = 16;
      ctx.fillStyle   = '#39ff14';
      ctx.font        = 'bold 24px Orbitron, sans-serif';
      ctx.textAlign   = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('PERFECT WAVE', W / 2, by + 24);

      ctx.shadowBlur  = 8;
      ctx.fillStyle   = 'rgba(57,255,20,0.7)';
      ctx.font        = '13px Share Tech Mono, monospace';
      ctx.fillText('+500 PTS', W / 2, by + 46);

      ctx.shadowBlur = 0;
      ctx.restore();
    }

    // â”€â”€ Muzzle flash â”€â”€
    if (muzzleFlashTimer > 0 && lives > 0) {
      ctx.save();
      ctx.globalAlpha = muzzleFlashTimer / 3; // fade over 3 frames
      ctx.shadowColor = '#00f0ff';
      ctx.shadowBlur  = 18;
      ctx.fillStyle   = '#fff';
      ctx.beginPath();
      ctx.arc(player.x, player.y - 26, 6 + (3 - muzzleFlashTimer) * 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    // â”€â”€ WAVE N flash (big center screen) â”€â”€
    if (waveFlashTimer > 0) {
      // Fade: in 15 frames, hold, out 15 frames
      let a = 1;
      if (waveFlashTimer > 75) a = (90 - waveFlashTimer) / 15;
      if (waveFlashTimer < 15) a = waveFlashTimer / 15;

      ctx.save();
      ctx.globalAlpha = a * 0.75; // semi-transparent so gameplay visible behind

      // Big "WAVE N" text
      ctx.shadowColor = 'rgba(0,240,255,0.7)';
      ctx.shadowBlur  = 28;
      ctx.fillStyle   = '#00f0ff';
      ctx.font        = 'bold 60px Orbitron, sans-serif';
      ctx.textAlign   = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('WAVE ' + waveFlashNumber, W / 2, H / 2 - 20);

      ctx.shadowBlur = 0;
      ctx.restore();
    }
  }
}

// â”€â”€â”€ LOOP (requestAnimationFrame, single rAF) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function loop(time) {
  update(time);
  draw(time);
  requestAnimationFrame(loop);
}

// â”€â”€â”€ PAUSE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function togglePause() {
  if (state !== 'playing' && state !== 'paused') return;
  paused = !paused;
  state = paused ? 'paused' : 'playing';
  pauseOverlay.classList.toggle('visible', paused);
}

// â”€â”€â”€ INPUT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.addEventListener('keydown', e => {
  keys[e.code] = true;
  if (e.code === 'Space') e.preventDefault();
  if (e.code === 'Escape') { e.preventDefault(); togglePause(); }
});
document.addEventListener('keyup', e => { keys[e.code] = false; });

// â”€â”€ Mobile on-screen controls: Joystick + Shoot button â”€â”€
const joystickArea  = document.getElementById('joystick-area');
const joystickStick = document.getElementById('joystick-stick');
const shootBtn      = document.getElementById('shoot-btn');

let joystickTouchId = null;
let shootTouchId    = null;

// â”€â”€ Joystick: capture on pad, track globally â”€â”€
if (joystickArea) {
  joystickArea.addEventListener('touchstart', e => {
    e.preventDefault();
    if (joystickTouchId !== null) return;
    joystickTouchId = e.changedTouches[0].identifier;
    initAudio();
    applyJoystick(e.changedTouches[0]);
  }, { passive: false });
}

// Shoot button: capture on button
if (shootBtn) {
  shootBtn.addEventListener('touchstart', e => {
    e.preventDefault();
    if (shootTouchId !== null) return;
    shootTouchId = e.changedTouches[0].identifier;
    touchShoot   = true;
    initAudio();
  }, { passive: false });
}

// â”€â”€ Global move â€” routes each tracked finger â”€â”€
document.addEventListener('touchmove', e => {
  for (let i = 0; i < e.changedTouches.length; i++) {
    const t = e.changedTouches[i];
    if (t.identifier === joystickTouchId) {
      e.preventDefault();
      applyJoystick(t);
    }
  }
}, { passive: false });

// â”€â”€ Global end / cancel â”€â”€
function onGlobalTouchEnd(e) {
  for (let i = 0; i < e.changedTouches.length; i++) {
    const id = e.changedTouches[i].identifier;
    if (id === joystickTouchId) {
      joystickTouchId = null;
      joystickActive  = false;
      joystickDeltaX  = 0;
      joystickStick.style.transform = 'translate(0px, 0px)';
    }
    if (id === shootTouchId) {
      shootTouchId = null;
      touchShoot   = false;
    }
  }
}
document.addEventListener('touchend',    onGlobalTouchEnd);
document.addEventListener('touchcancel', onGlobalTouchEnd);

// â”€â”€ Joystick math: horizontal-only, with dead-zone â”€â”€
function applyJoystick(touch) {
  // Get joystick center in viewport coords
  const rect = joystickArea.getBoundingClientRect();
  const centerX = rect.left + rect.width / 2;
  const centerY = rect.top + rect.height / 2;
  
  // Touch coords in viewport
  const touchX = touch.clientX;
  const touchY = touch.clientY;
  
  // Calculate offset from center
  let dx = touchX - centerX;
  let dy = touchY - centerY;
  
  // For horizontal-only joystick, we only care about X axis
  // But if container is rotated, X and Y are swapped in physical space
  // Detect rotation and swap axes if needed
  const isRotated = window.matchMedia('(max-width: 768px) and (orientation: portrait)').matches;
  
  if (isRotated) {
    // When rotated 90deg clockwise, physical left-right becomes viewport up-down
    // So we use dy (vertical movement in viewport) as our dx (horizontal in game)
    const temp = dx;
    dx = -dy;  // negative because viewport Y increases downward
    dy = temp;
  }

  const maxDist = rect.width / 2 - 12;
  if (dx >  maxDist) dx =  maxDist;
  if (dx < -maxDist) dx = -maxDist;

  // Dead zone â€” ~5% of radius prevents drift when thumb is "still"
  const dead = maxDist * 0.05;
  if (Math.abs(dx) < dead) dx = 0;

  joystickStick.style.transform = `translate(${dx}px, 0px)`;
  joystickActive = true;
  joystickDeltaX = dx / maxDist; // -1 â€¦ 0 â€¦ +1
}

// â”€â”€â”€ START / MENU â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function startGame() {
  pauseOverlay.classList.remove('visible');
  newHsBanner.classList.remove('visible');
  confettiCanvas.classList.remove('visible');
  if (confettiAnimId) { cancelAnimationFrame(confettiAnimId); confettiAnimId = null; }
  paused = false;
  score = 0; wave = 0; lives = 4; waveDelay = 50;
  deathReason = '';
  liveLog = [];
  btnRow.innerHTML = '';  // nuke any leftover overlay buttons from DOM
  scoreText.textContent = '0';
  waveText.textContent = '1';
  player = createPlayer();
  bullets = []; enemies = []; enemyBullets = []; explosions = [];
  for (let i = 0; i < MAX_PARTICLES; i++) particlePool[i].active = false;
  particleCount = 0;
  updateLives();
  menuHsEl.classList.remove('visible');
  overlay.classList.add('hidden');
  touchMoveX = null;
  touchShoot = false;
  joystickActive = false;
  joystickDeltaX = 0;
  playerStillFrames = 0; // Reset camping tracker
  playerLastX = W / 2;
  stopMusic(); // Stop menu music
  if (isTouchDevice) pauseBtnEl.classList.add('visible');
  state = 'playing';
}

// â”€â”€â”€ INIT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
initStars();
bullets = []; enemies = []; enemyBullets = []; explosions = [];
for (let i = 0; i < MAX_PARTICLES; i++) particlePool[i] = { active: false };
particleCount = 0;
loadHighScore().then(() => showMenu());
initCustomSliders();
requestAnimationFrame(loop);
</script>
</body>
</html>
